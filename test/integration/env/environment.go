// SPDX-FileCopyrightText: 2021 SAP SE or an SAP affiliate company and Gardener contributors
//
// SPDX-License-Identifier: Apache-2.0

package env

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"time"

	authenticationv1 "k8s.io/api/authentication/v1"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	utilerrors "k8s.io/apimachinery/pkg/util/errors"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	configlatest "k8s.io/client-go/tools/clientcmd/api/latest"
	configv1 "k8s.io/client-go/tools/clientcmd/api/v1"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
)

type OIDCWebhookTestEnvironment struct {
	*envtest.Environment

	// certDir contains the kube-apiserver certs (generated by controller-runtime's pkg/envtest) and the front-proxy
	// certs for the API server aggregation layer
	certDir          string
	aggregatorConfig AggregatorConfig

	// oidcWebhookServer knows how to start, register and stop a temporary oidc-webhook-authenticator instance.
	oidcWebhookServer *oidcWebhookServer

	// OIDCOut, OIDCErr specify where the OIDC Webhook Authenticator should write its StdOut, StdErr to.
	// If not specified, the output will be discarded.
	OIDCOut io.Writer
	OIDCErr io.Writer

	// OIDCOut, OIDCErr specify where the kube-apiserver should write its StdOut, StdErr to.
	// If not specified, the output will be discarded.
	APIServerOut io.Writer
	APIServerErr io.Writer
}

// Start starts the underlying envtest.Environment and the OIDC Webhook Server.
func (e *OIDCWebhookTestEnvironment) Start() (*rest.Config, error) {
	if e.Environment == nil {
		e.Environment = &envtest.Environment{}
	}
	kubeAPIServer := e.Environment.ControlPlane.GetAPIServer()

	kubeAPIServer.Out = e.APIServerOut
	kubeAPIServer.Err = e.APIServerErr

	// manage k-api cert dir by ourselves, we will add aggregator certs to it
	var err error
	e.certDir, err = os.MkdirTemp("", "k8s_oidc_test_framework_")
	if err != nil {
		return nil, err
	}
	kubeAPIServer.CertDir = e.certDir
	kubeAPIServer.Configure().Set("bind-address", "127.0.0.1")

	// configure kube-aggregator
	if err := e.aggregatorConfig.ConfigureAPIServerArgs(e.certDir, kubeAPIServer.Configure()); err != nil {
		return nil, err
	}

	// configure default oidc webhook server
	e.oidcWebhookServer = &oidcWebhookServer{
		Out: e.OIDCOut,
		Err: e.OIDCErr,
	}
	e.oidcWebhookServer.configureDefaults()

	// configure webhook authentication
	authKubeconfigPath := filepath.Join(e.certDir, "auth-webhook.yaml")
	kubeAPIServer.Configure().Set("authentication-token-webhook-cache-ttl", "0s")
	kubeAPIServer.Configure().Set("authentication-token-webhook-config-file", authKubeconfigPath)
	authKubeconfig, err := prepareKubeconfig("https://localhost:10443/validate-token", e.oidcWebhookServer.CaCert.CertificatePEM, configv1.AuthInfo{
		TokenFile: filepath.Join(e.certDir, "kube-apiserver-token"),
	})
	if err != nil {
		return nil, err
	}

	err = os.WriteFile(authKubeconfigPath, authKubeconfig, 0640)
	if err != nil {
		return nil, err
	}

	// write something to the token file so that the controlplane can start
	err = os.WriteFile(filepath.Join(e.certDir, "kube-apiserver-token"), []byte("Hello!"), 0640)
	if err != nil {
		return nil, err
	}

	// start kube control plane
	adminRestConfig, err := e.Environment.Start()
	if err != nil {
		return nil, err
	}

	// setup oidc webhook permissions
	clientset, err := kubernetes.NewForConfig(adminRestConfig)
	if err != nil {
		return nil, err
	}

	ctx := context.Background()
	kubeApiserverToken, err := setupKubeApiserverRbacAndReturnToken(ctx, clientset)
	if err != nil {
		return nil, err
	}

	err = os.WriteFile(filepath.Join(e.certDir, "kube-apiserver-token"), []byte(kubeApiserverToken), 0640)
	if err != nil {
		return nil, err
	}

	token, err := setupOIDCRbacAndReturnServiceAccountToken(ctx, clientset)
	if err != nil {
		return nil, err
	}

	kubeconfigBytes, err := prepareKubeconfig(adminRestConfig.Host, adminRestConfig.CAData, configv1.AuthInfo{Token: token})
	if err != nil {
		return nil, err
	}

	kubeconfigFile := filepath.Join(e.oidcWebhookServer.KubeconfigDir, "kubeconfig.yaml")
	err = os.WriteFile(kubeconfigFile, kubeconfigBytes, 0640)
	if err != nil {
		return nil, err
	}

	if err := e.oidcWebhookServer.start(); err != nil {
		return nil, fmt.Errorf("failed to start oidc-webhook-authenticator: %w", err)
	}

	return adminRestConfig, nil
}

// Stop stops the underlying envtest.Environment and the OIDC Webhook Server.
func (e *OIDCWebhookTestEnvironment) Stop() error {
	var errList []error

	if e.oidcWebhookServer != nil {
		if err := e.oidcWebhookServer.stop(); err != nil {
			errList = append(errList, err)
		}
	}

	if e.Environment != nil {
		if err := e.Environment.Stop(); err != nil {
			errList = append(errList, err)
		}
	}

	if e.certDir != "" {
		if err := os.RemoveAll(e.certDir); err != nil {
			errList = append(errList, err)
		}
	}

	return utilerrors.Flatten(utilerrors.NewAggregate(errList))
}

// OIDCServerCA returns the PEM encoded certificate authority for the OIDC Webhook Server.
func (e *OIDCWebhookTestEnvironment) OIDCServerCA() []byte {
	return e.oidcWebhookServer.CaCert.CertificatePEM
}

func setupKubeApiserverRbacAndReturnToken(ctx context.Context, c *kubernetes.Clientset) (string, error) {
	svca := &corev1.ServiceAccount{
		ObjectMeta: metav1.ObjectMeta{
			Namespace: "default",
			Name:      "kube-apiserver",
		},
	}
	_, err := c.CoreV1().ServiceAccounts("default").Create(ctx, svca, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	rbacName := "token-validator"
	_, err = c.RbacV1().ClusterRoles().Create(ctx, &rbacv1.ClusterRole{
		ObjectMeta: metav1.ObjectMeta{
			Name: rbacName,
		},
		Rules: []rbacv1.PolicyRule{{
			Verbs:           []string{"post"},
			NonResourceURLs: []string{"/validate-token"},
		}},
	}, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	_, err = c.RbacV1().ClusterRoleBindings().Create(ctx, &rbacv1.ClusterRoleBinding{
		ObjectMeta: metav1.ObjectMeta{
			Name: rbacName,
		},
		Subjects: []rbacv1.Subject{{
			Name:      "kube-apiserver",
			Namespace: "default",
			Kind:      "ServiceAccount",
		}},
		RoleRef: rbacv1.RoleRef{
			APIGroup: "rbac.authorization.k8s.io",
			Kind:     "ClusterRole",
			Name:     rbacName,
		},
	}, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	ttl := int64((30 * time.Minute).Seconds())
	resp, err := c.CoreV1().ServiceAccounts("default").CreateToken(ctx, "kube-apiserver", &authenticationv1.TokenRequest{
		Spec: authenticationv1.TokenRequestSpec{
			ExpirationSeconds: &ttl,
		},
	}, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	return resp.Status.Token, nil
}

func setupOIDCRbacAndReturnServiceAccountToken(ctx context.Context, c *kubernetes.Clientset) (string, error) {
	svca := &corev1.ServiceAccount{
		ObjectMeta: metav1.ObjectMeta{
			Namespace: "default",
			Name:      "oidc-webhook-authenticator",
		},
	}
	_, err := c.CoreV1().ServiceAccounts("default").Create(ctx, svca, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	clusterRole := &rbacv1.ClusterRole{
		ObjectMeta: metav1.ObjectMeta{
			Name: "oidc-webhook-authenticator",
		},
		Rules: []rbacv1.PolicyRule{
			{
				APIGroups: []string{"authentication.gardener.cloud"},
				Verbs:     []string{"get", "list", "watch"},
				Resources: []string{"openidconnects"},
			},
		},
	}
	_, err = c.RbacV1().ClusterRoles().Create(ctx, clusterRole, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	clusterRoleBinding := &rbacv1.ClusterRoleBinding{
		ObjectMeta: metav1.ObjectMeta{
			Name: "oidc-webhook-authenticator",
		},
		RoleRef: rbacv1.RoleRef{
			APIGroup: "rbac.authorization.k8s.io",
			Kind:     "ClusterRole",
			Name:     "oidc-webhook-authenticator",
		},
		Subjects: []rbacv1.Subject{
			{
				APIGroup:  "",
				Kind:      "ServiceAccount",
				Namespace: "default",
				Name:      "oidc-webhook-authenticator",
			},
		},
	}
	_, err = c.RbacV1().ClusterRoleBindings().Create(ctx, clusterRoleBinding, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	roleBinding := &rbacv1.RoleBinding{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "oidc-webhook-authenticator",
			Namespace: "kube-system",
		},
		RoleRef: rbacv1.RoleRef{
			APIGroup: "rbac.authorization.k8s.io",
			Kind:     "Role",
			Name:     "extension-apiserver-authentication-reader",
		},
		Subjects: []rbacv1.Subject{
			{
				Kind:      "ServiceAccount",
				Name:      "oidc-webhook-authenticator",
				Namespace: "default",
			},
		},
	}

	_, err = c.RbacV1().RoleBindings("kube-system").Create(ctx, roleBinding, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	clusterRoleBindingAuthDelegator := &rbacv1.ClusterRoleBinding{
		ObjectMeta: metav1.ObjectMeta{
			Name: "oidc-webhook-authenticator-auth-delegator",
		},
		RoleRef: rbacv1.RoleRef{
			APIGroup: "rbac.authorization.k8s.io",
			Kind:     "ClusterRole",
			Name:     "system:auth-delegator",
		},
		Subjects: []rbacv1.Subject{
			{
				APIGroup:  "",
				Kind:      "ServiceAccount",
				Namespace: "default",
				Name:      "oidc-webhook-authenticator",
			},
		},
	}
	_, err = c.RbacV1().ClusterRoleBindings().Create(ctx, clusterRoleBindingAuthDelegator, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	ttl := int64((30 * time.Minute).Seconds())
	resp, err := c.CoreV1().ServiceAccounts("default").CreateToken(ctx, "oidc-webhook-authenticator", &authenticationv1.TokenRequest{
		Spec: authenticationv1.TokenRequestSpec{
			ExpirationSeconds: &ttl,
		},
	}, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	return resp.Status.Token, nil
}

func prepareKubeconfig(host string, caData []byte, authInfo configv1.AuthInfo) ([]byte, error) {
	name := "server"
	conf := &configv1.Config{
		Clusters: []configv1.NamedCluster{{
			Name: name,
			Cluster: configv1.Cluster{
				Server:                   host,
				CertificateAuthorityData: caData,
				InsecureSkipTLSVerify:    false,
			},
		}},
		Contexts: []configv1.NamedContext{{
			Name: name,
			Context: configv1.Context{
				Cluster:  name,
				AuthInfo: name,
			},
		}},
		CurrentContext: name,
		AuthInfos: []configv1.NamedAuthInfo{{
			Name:     name,
			AuthInfo: authInfo,
		}},
	}

	confBytes, err := runtime.Encode(configlatest.Codec, conf)
	if err != nil {
		return nil, err
	}

	return confBytes, nil
}
